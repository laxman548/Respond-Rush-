<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Level Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GSAP CDN for Level 1 Game -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100vw; /* Ensure body takes full width */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            transition: background-color 0.5s ease; /* Smooth transition for background */
        }
        /* Custom styles for game elements */
        .game-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* rounded-3xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 2.5rem; /* p-10 */
            max-width: 1000px; /* Adjusted for better laptop screen fit */
            height: 80vh; /* Adjusted for better laptop screen fit */
            width: 100%;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .game-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem; /* py-3 px-6 */
            border-radius: 0.75rem; /* rounded-xl */
            font-weight: 600; /* font-semibold */
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .game-button-primary {
            background-image: linear-gradient(to right top, #6366f1, #8b5cf6, #a855f7, #c042f8, #d825f8); /* bg-gradient-to-r from-indigo-500 to-purple-600 */
            color: #ffffff; /* text-white */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
        }
        .game-button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .game-button-primary:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .game-button-secondary {
            background-color: #e2e8f0; /* bg-gray-200 */
            color: #475569; /* text-slate-700 */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
        }
        .game-button-secondary:hover {
            background-color: #cbd5e1; /* bg-gray-300 */
        }
        .game-button-secondary:active {
            background-color: #94a3b8; /* bg-slate-400 */
        }
        .level-screen {
            display: none; /* Hidden by default */
            width: 100%;
        }
        .level-screen.active {
            display: block; /* Shown when active */
        }
        .disabled-button {
            opacity: 0.6;
            cursor: not-allowed;
            background-image: none !important;
            background-color: #a3a3a3 !important;
            box-shadow: none !important;
            transform: none !important;
        }

        /* --- Level 1 Game Specific CSS (from style.css) --- */
        /* Background classes (these will not be used by Level 1's internal showScreen, but are kept for reference if needed elsewhere) */
        .bg-start {
            background-color: #a8dadc; /* Light Blue */
        }
        .bg-game {
            background-color: #b8e0d4; /* Mint Green */
        }
        .bg-round2-intro {
            background-color: #f7d9c4; /* Light Peach */
        }
        .bg-game-over {
            background-color: #f4a261; /* Orange-Red */
        }

#game-screen-level1 {
    background-color: transparent !important;
    border: none !important;
    box-shadow: none !important;
}

      
        .hidden {
            display: none;
        }

        /* Start Screen */
        #start-screen-level1 h1 {
            color: #4CAF50;
        }
        #start-screen-level1 button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #start-screen-level1 button:hover {
            background-color: #45a049;
        }


        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }

        #instruction-area {
            display: none; /* This will be managed by JS to show/hide */
        }


        #character-container {
            width: 100%;
            max-width: 610px;
            height: 390px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            /* Replaced local image with placeholder */
            background-image: url('https://placehold.co/610x390/E0BBE4/FFFFFF?text=Stickman+Background'); /* REPLACE WITH YOUR IMAGE URL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 10px;
            border: 2px solid #333333;
            margin: 0 auto 20px ;
            overflow: hidden;
        }


        /* --- STICK MAN DRAWING AND BASE STYLES --- */
        #stick-man {
            width: 80px;
            height: 150px;
            position: absolute;
            bottom: 50px;
            right: 280px; /* Adjust as needed for centering within its container */
            transform-origin: bottom center;
            transition: transform 0.2s ease-out;
            z-index: 1;
        }


        #stick-man .head {
            width: 60px;
            height: 60px;
            background-color: white; /* White for the head to match the image */
            border: 3px solid black;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 10px; /* Center relative to 80px width of stick-man */
            z-index: 2;
            transform-origin: bottom center; /* For head rotation/movement */
            transition: transform 0.2s ease-out; /* Base transition for head */
            overflow: hidden; /* Crucial to keep mouth inside head border */
        }

        #stick-man .eyes { /* Simple dot eyes like the reference image */
            position: absolute;
            top: 20px; /* Adjust vertical position */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: 40px; /* Span for both eyes */
            display: flex;
            justify-content: space-between; /* Space between the two pseudo-elements */
            z-index: 3;
        }
        #stick-man .eyes::before, #stick-man .eyes::after {
            content: '';
            display: block;
            width: 8px; /* Size of the eye dot */
            height: 8px; /* Size of the eye dot */
            background-color: black;
            border-radius: 50%;
        }

        #stick-man .mouth { /* The expressive mouth, initial closed state */
            position: absolute;
            top: 38px; /* Adjust vertical position within head */
            left: 50%;
            /* Removed transform: translateX(-50%); to avoid conflict with GSAP's xPercent */
            width: 25px; /* Initial closed width */
            height: 5px; /* Initial closed height (line) */
            background-color: transparent; /* Mouth opening reveals head color */
            border: 2px solid black; /* The outline of the mouth */
            border-radius: 50%; /* Start as a rounded line/small oval */
            z-index: 3;
            transition: all 0.2s ease-out; /* Smooth transition for mouth shape, GSAP will override this during animation */
        }


        #stick-man .body {
            width: 40px;
            height: 80px;
            background-color: black; /* Solid black body */
            border-radius: 5px 5px 20px 20px; /* Slightly rounded body */
            position: absolute;
            top: 55px; /* Below head */
            left: 20px; /* Center relative to 80px width */
            z-index: 1;
            transform-origin: top center; /* For body bending */
            transition: transform 0.2s ease-out; /* Base transition for body */
        }

        #stick-man .left-arm,
        #stick-man .right-arm {
            width: 10px;
            height: 60px;
            background-color: black;
            border-radius: 5px;
            position: absolute;
            top: 60px; /* Attach to body */
            transform-origin: top center;
            z-index: 0; /* Behind body for default */
            /* Default rotation. GSAP will animate from and to these values. */
            transition: transform 0.2s ease-out; /* Base transition for arm movements */
        }

        #stick-man .left-arm {
            left: 15px; /* Adjust to connect to body */
            transform: rotate(15deg); /* Slightly angled default */
        }

        #stick-man .right-arm {
            right: 15px; /* Adjust to connect to body */
            transform: rotate(-15deg); /* Slightly angled default */
        }

        #stick-man .left-leg,
        #stick-man .right-leg {
            width: 10px;
            height: 70px;
            background-color: black;
            border-radius: 5px;
            position: absolute;
            top: 120px; /* Attach to bottom of body */
            transform-origin: top center;
            /* Default rotation. GSAP will animate from and to these values. */
            transition: transform 0.2s ease-out; /* Base transition for leg movements */
        }

        #stick-man .left-leg {
            left: 25px;
            transform: rotate(5deg);
        }

        #stick-man .right-leg {
            right: 25px;
            transform: rotate(-5deg);
        }

        /*
            *** IMPORTANT ***
            ALL @keyframes ANIMATIONS ARE HANDLED BY GSAP IN script.js.
            DO NOT ADD THEM HERE TO AVOID CONFLICTS.
        */

#game-screen-level1 h2 {
    margin-bottom: 20px;
}

        /* Action Buttons */
        #action-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        #action-buttons button {
            padding: 15px 30px;
            font-size: 1.2em;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 120px;
            transition: background-color 0.2s ease; /* Smooth hover */
        }

        #action-buttons button:hover {
            background-color: #0056b3;
        }

        /* Round 2 Intro Screen */
       #round-2-intro-level1 {
    background-color: #FFC107;
    color: #333;
    padding: 40px 30px; /* Increased padding for size */
    border: 2px solid black; /* Thin black border */
    border-radius: 15px;
    max-width: 90%;
    width: 100%;
    box-sizing: border-box;
}
#round-2-intro-level1 p, #round-2-intro-level1 ul {
    line-height: 1.6;
}


        #round-2-intro-level1 h2 {
            color: #b38e00;
        }
        #round-2-intro-level1 p {
            margin: 15px 0 5px; /* Adjust margin for list */
            font-size: 1.1em;
        }
        #round-2-intro-level1 ul {
            list-style: none; /* Remove default bullet points */
            padding: 0;
            margin: 5px 0 20px; /* Adjust margin for list */
            font-size: 1.1em;
        }
        #round-2-intro-level1 li {
            margin-bottom: 5px;
        }
        #round-2-intro-level1 li strong {
            color: #E91E63; /* Highlight action names */
        }
        #round-2-intro-level1 button {
            padding: 10px 20px;
            font-size: 1.2em;
            background-color: #b38e00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.2s ease;
        }
        #round-2-intro-level1 button:hover {
            background-color: #8c6e00;
        }


        /* Game Over Screen Styles */
        #game-over-screen-level1 { /* Renamed to avoid conflict */
            background-color: #f44336; /* Red color for game over */
            color: white;
        }
        #game-over-screen-level2 { /* Renamed to avoid conflict */
            background-color: #f44336; /* Red color for game over */
            color: white;
        }
        #game-over-screen-level1 h2 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 15px;
        }
        #game-over-screen-level1 p {
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        #game-over-screen-level1 .final-score {
            font-size: 4em;
            font-weight: bold;
            color: #fff; /* Keep score bright white */
            margin-bottom: 30px;
        }
        #game-over-screen-level1 button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #e57373; /* Lighter red for button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            margin: 10px; /* Add margin between buttons */
            transition: background-color 0.2s ease;
        }
        #game-over-screen-level1 button:hover {
            background-color: #d32f2f; /* Darker red on hover */
        }
        /* --- END Level 1 Game Specific CSS --- */

        /* --- Level 2 Game Specific CSS --- */
        /* Overriding global body styles for Level 2's internal container */
      /* --- Level 2 Game Specific CSS --- */
/* Overriding global body styles for Level 2's internal container */
.game-container-level2-internal {
    width: 90%;
    max-width: 800px;
    height: 600px;
    background-color: #34495e; /* Changed from #34495e to transparent */
    border-radius: 15px;
    box-shadow: none; /* Changed from 0 10px 30px rgba(0, 0, 0, 0.5) to none */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: 30px;
    box-sizing: border-box;
    position: relative;
    transform-style: preserve-3d;
    transform: rotateX(10deg) rotateY(0deg);
    z-index: 1;
    color: #ecf0f1; /* Inherit text color from original Level 2 body */
}

        
        .game-container-level2-internal.paused .display-board,
        .game-container-level2-internal.paused .choices-container,
        .game-container-level2-internal.paused .info-panel {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }


        .display-board {
            width: 80%;
            height: 150px;
            background-color: transparent;
            border: 5px solid #00ff00;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            position: relative;
            z-index: 5;
            transition: opacity 0.3s ease;
           

        }

        #word-display-level2 { /* Updated ID */
            font-size: 4em;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            transition: color 0.1s ease-in-out;
        }

        .choices-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            position: relative;
            z-index: 5;
            transition: opacity 0.3s ease;
        }

        @-webkit-keyframes discoBorder {
            0% { border-color: #FF00FF; }
            16% { border-color: #00FFFF; }
            33% { border-color: #FFFF00; }
            50% { border-color: #FF1493; }
            66% { border-color: #00FF00; }
            83% { border-color: #8A2BE2; }
            100% { border-color: #FF00FF; }
        }

        @keyframes discoBorder {
            0% { border-color: #FF00FF; }
            16% { border-color: #00FFFF; }
            33% { border-color: #FFFF00; }
            50% { border-color: #FF1493; }
            66% { border-color: #00FF00; }
            83% { border-color: #8A2BE2; }
            100% { border-color: #FF00FF; }
        }

        .color-button {
            width: 120px;
            height: 120px;
            background-color: transparent;
            border: 3px solid;
            border-radius: 15px;
            cursor: pointer;
            -webkit-animation: discoBorder 4s linear infinite;
            animation: discoBorder 4s linear infinite;
            transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.2s ease, filter 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
        }

        .color-button-text {
            font-size: 1.8em;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            color: #ecf0f1;
            pointer-events: none;
        }


        .color-button:hover:not(:disabled) {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(255, 255, 255, 0.4);
            border-color: #ecf0f1;
            -webkit-animation: none;
            animation: none;
        }

        .color-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            border-color: #7f8c8d;
        }

        .color-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            filter: grayscale(50%);
            transform: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            border-color: #7f8c8d;
            -webkit-animation: none;
            animation: none;
        }

        .info-panel {
            width: 80%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            padding: 10px 0;
            position: relative;
            z-index: 5;
            transition: opacity 0.3s ease;
        }

        .timer-bar-container {
            width: 200px;
            height: 15px;
            background-color: #555;
            border-radius: 5px;
            overflow: hidden;
            margin-left: 20px;
        }

        .timer-bar {
            width: 100%;
            height: 100%;
            background-color: #2ecc71;
            border-radius: 5px;
        }
        /* Remove or modify this rule if it's still affecting the main Level 2 title */
.game-screen-level2-internal h2 {
    position: absolute;
    top: 500px;
}
        .game-screen-level2-internal { /* Renamed */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 80%;
            background-color: #34495e; /* Solid background color for Level 2 internal screens */
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-screen-level2-internal.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .game-screen-level2-internal h1, .game-screen-level2-internal h2 {
            color: #e74c3c;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
           
        }
         .game-screen-level2-internal h2 {
            position: absolute;
            top: 50px;
         }
        #start-screen-level1 h1 {
    font-size: 3rem; /* Increase font size */
    font-weight: 900;
    background: linear-gradient(to right, black, red, brown, #FF1493, blue, #8A2BE2);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: colorShift 4s linear infinite;
    background-color: #a8dadc;

    background-color: rgba(0, 0, 0, 0.1);  /* Light translucent background */
    padding: 10px 20px;
    border-radius: 12px;
    display: inline-block;

}


        .game-screen-level2-internal p {
            font-size: 1.5em;
            margin-bottom: 30px;
            max-width: 80%;
        }

        .game-screen-level2-internal button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .game-screen-level2-internal button:hover {
            background-color: #2ecc71;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .game-screen-level2-internal button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 768px) {
            .game-container-level2-internal { /* Updated class */
                width: 95%;
                height: auto;
                padding: 20px;
            }

            #word-display-level2 { /* Updated ID */
                font-size: 3em;
            }

            .color-button {
                width: 100px;
                height: 100px;
            }

            .color-button-text {
                font-size: 1.5em;
            }

            .game-screen-level2-internal h1, .game-screen-level2-internal h2 { /* Updated class */
                font-size: 2.5em;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                max-width: 95vw;
                height: 90vh;
            }
            #word-display-level2 { /* Updated ID */
                font-size: 2.5em;
            }

            .color-button {
                width: 80px;
                height: 80px;
                margin: 5px;
            }

            .color-button-text {
                font-size: 1.2em;
            }

            .choices-container {
                gap: 10px;
            }

            .info-panel {
                flex-direction: column;
                gap: 10px;
                font-size: 1em;
            }

            .timer-bar-container {
                width: 150px;
                margin-left: 0;
            }

            .game-screen-level2-internal h1, .game-screen-level2-internal h2 { /* Updated class */
                font-size: 2em;
            }

            .game-screen-level2-internal p { /* Updated class */
                font-size: 1.2em;
            }

            .game-screen-level2-internal button { /* Updated class */
                padding: 10px 20px;
                font-size: 1.2em;
            }
        }
        .no-background {
    background-color: transparent !important;
    box-shadow: none !important;
    border: none !important;
}

        /* --- END Level 2 Game Specific CSS --- */
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="gameContainer" class="game-container">
        <!-- Start Screen -->
        <div id="startScreen" class="level-screen active">
            <h1 class="text-5xl font-bold text-gray-800 mb-6">Welcome to the Game!</h1>
            <p class="text-xl text-gray-600 mb-8">Complete Level 1 to unlock Level 2.</p>
            <button id="startButton" class="game-button game-button-primary text-2xl">Start Game</button>
        </div>

        <!-- Level 1 Screen -->
        <div id="level1Screen" class="level-screen">

            <p class="text-lg text-gray-700 mb-8">
                
                <br>
                
            </p>
            <!-- Placeholder for Level 1 Game Content -->
            <div id="level1GameContent" class="w-full flex flex-col items-center justify-center mb-8">

                <!-- *** INTEGRATED LEVEL 1 GAME HTML HERE *** -->
                <div class="game-screen-level1-internal" id="start-screen-level1">
                    <h1>Response Rush!</h1>
                    <p>Round 1: Follow the instructions on screen.</p>
                    <p>Round 2: Do the mapped action instead of the instruction.</p>
                    <button id="start-button-level1">Start Game</button>
                </div>

                <div class="game-screen-level1-internal hidden" id="game-screen-level1">
                    <div id="score-display">Score: 0</div>
                    <div id="instruction-area"></div>
                    <h2 class="text-4xl font-bold text-indigo-700 mb-6">Level 1: Response Rush!</h2>

                    <div id="character-container">
                        <!-- Using a placeholder for the background image -->
                        <img src="backgroud of stickmam.jpeg" alt="Background for Stickman">
                        <div id="stick-man">
                            <div class="head">
                                <div class="eyes"></div>
                                <div class="mouth"></div>
                            </div>
                            <div class="body"></div>
                            <div class="left-arm"></div>
                            <div class="right-arm"></div>
                            <div class="left-leg"></div>
                            <div class="right-leg"></div>
                        </div>
                    </div>

                    <div id="action-buttons">
                        <button data-action="jump">Jump</button>
                        <button data-action="dance">Dance</button>
                        <button data-action="shout">Shout</button>
                    </div>
                </div>

                <div class="game-screen-level1-internal hidden" id="round-2-intro-level1">
                    <h2>Prepare for Round 2!</h2>
                    <p>The rules are changing! Here's the new mapping:</p>
                    <ul>
                        <li>If instruction = <strong>Jump</strong> &rarr; Click <strong>Shout</strong></li>
                        <li>If instruction = <strong>Dance</strong> &rarr; Click <strong>Jump</strong></li>
                        <li>If instruction = <strong>Shout</strong> &rarr; Click <strong>Dance</strong></li>
                    </ul>
                    <button id="proceed-to-round2-button-level1">Start Round 2</button>
                </div>

                <div class="game-screen-level1-internal hidden" id="game-over-screen-level1">
                    <h2>Game Over!</h2>
                    <p>Your Final Score:</p>
                    <div class="final-score" id="final-score">0</div>
                    <button id="play-again-button-level1">Play Again</button>
                    <button id="back-to-home-button-level1">Back to Home</button>
                </div>
                <!-- *** END INTEGRATED LEVEL 1 GAME HTML *** -->
            </div>
        </div>

        <!-- Level 1 Complete Screen -->
        <div id="level1CompleteScreen" class="level-screen">
            <h2 class="text-4xl font-bold text-green-700 mb-6">Level 1 Completed! üéâ</h2>
            <p class="text-xl text-gray-700 mb-8">Congratulations! You've mastered the first challenge.</p>
            <p class="text-2xl font-bold text-gray-800 mb-4">Your Level 1 Score: <span id="level1-final-score">0</span></p>
            <button id="goToLevel2Button" class="game-button game-button-primary text-2xl disabled-button" disabled>Go to Level 2</button>
        </div>

        <!-- Level 2 Screen -->
   <div id="level2Screen" class="level-screen">
           <h2 class="text-4xl font-bold text-blue-700 mb-6">Level 2: Response Rush!</h2> <p class="text-lg text-gray-700 mb-8">
               <br>
           </p>
           <div id="level2GameContent" class="w-full flex flex-col items-center justify-center mb-8">
               <div class="game-container-level2-internal">
                   <div id="display-board-level2" class="display-board">
                       <span id="word-display-level2"></span>
                   </div>

                   <div class="choices-container">
                       <button class="color-button" id="choice-1-level2"><span class="color-button-text"></span></button>
                       <button class="color-button" id="choice-2-level2"><span class="color-button-text"></span></button>
                       <button class="color-button" id="choice-3-level2"><span class="color-button-text"></span></button>
                       <button class="color-button" id="choice-4-level2"><span class="color-button-text"></span></button>
                   </div>

                   <div class="info-panel">
                       <p>Score: <span id="score-level2">0</span> / 15</p>
                       <p>Round: <span id="round-level2">1</span> / 15</p>
                       <div class="timer-bar-container">
                           <div id="timer-bar-level2" class="timer-bar"></div>
                       </div>
                   </div>

                   <div id="start-screen-level2" class="game-screen-level2-internal active">
                       <h1>Response Rush!</h1>
                       <p>Identify the color of the text, not the word!</p>
                       <button id="start-game-button-level2">Start Game</button>
                   </div>

                   <div id="end-screen-level2" class="game-screen-level2-internal">
                       <h2>Game Over!</h2>
                       <p>Final Score: <span id="final-score-level2"></span> / 15</p>
                       <button id="restart-game-button-level2">Play Again</button>
                   </div>
               </div>
           </div>
       </div>

        <!-- Game Over/Completion Screen -->
        <div id="gameOverScreen" class="level-screen">
            <h2 class="text-4xl font-bold text-purple-700 mb-6">Game Completed! üèÜ</h2>
            <p class="text-xl text-gray-700 mb-8">You've successfully completed all levels! Amazing work!</p>
            <p class="text-2xl font-bold text-gray-800 mb-4">Your Total Score: <span id="game-total-score">0</span></p>
            <button id="playAgainButton" class="game-button game-button-secondary text-xl">Play Again</button>
        </div>
    </div>

    <script>
        // Get references to all screens and buttons
        const startScreen = document.getElementById('startScreen');
        const level1Screen = document.getElementById('level1Screen');
        const level1CompleteScreen = document.getElementById('level1CompleteScreen');
        const level2Screen = document.getElementById('level2Screen');
        const gameOverScreen = document.getElementById('gameOverScreen');

        const startButton = document.getElementById('startButton');
        const goToLevel2Button = document.getElementById('goToLevel2Button');
        const playAgainButton = document.getElementById('playAgainButton');

        // Score display elements
        const level1FinalScoreDisplay = document.getElementById('level1-final-score');
        const gameTotalScoreDisplay = document.getElementById('game-total-score');


        // Game state variables
        let level1Completed = false;

        // Function to show a specific screen and hide others
        function showScreen(screenToShow) {
            [startScreen, level1Screen, level1CompleteScreen, level2Screen, gameOverScreen].forEach(screen => {
                screen.classList.remove('active');
            });
            screenToShow.classList.add('active');
        }

        // Helper function to show/hide internal screens within a game module
        // This function is now global and accessible to both level modules
        function showInternalScreen(containerElement, screenToShow) {
            // Get all internal screens within the specific container
            const internalScreens = containerElement.querySelectorAll('.game-screen-level1-internal, .game-screen-level2-internal');
            internalScreens.forEach(screen => {
                screen.classList.add('hidden');
                screen.classList.remove('active'); // Ensure active class is also removed
            });
            if (screenToShow) {
                screenToShow.classList.remove('hidden');
                screenToShow.classList.add('active');
            }
        }


        // Event Listeners
        startButton.addEventListener('click', () => {
            showScreen(level1Screen);
            console.log("Main Start Button clicked. Showing Level 1 screen.");
            // Call your Level 1 game's initialization function here
            initializeLevel1Game();
        });

        goToLevel2Button.addEventListener('click', () => {
            if (level1Completed) {
                showScreen(level2Screen);
                console.log("Go to Level 2 button clicked. Showing Level 2 screen.");
                // Call your Level 2 game's initialization function here
                initializeLevel2Game();
            } else {
                console.warn("Level 1 not completed yet!");
            }
        });

        playAgainButton.addEventListener('click', () => {
            level1Completed = false; // Reset game state
            showScreen(startScreen);
            console.log("Play Again button clicked. Returning to Start Screen.");
            // Reset both game levels here if they have internal states that need clearing
            resetLevel1Game();
            resetLevel2Game();
            // Re-disable the "Go to Level 2" button
            goToLevel2Button.classList.add('disabled-button');
            goToLevel2Button.disabled = true;
        });

        // --- Your Actual Game Logic Functions Go Below ---

        /**
         * Initializes Level 1 game.
         * Copy your Level 1 game's JavaScript code into this function.
         * Ensure any global variables from your original game are either
         * made local to this function or carefully managed to avoid conflicts.
         */
        const level1Game = (function() {
            let score = 0;
            let currentRound = 1;
            let currentInstruction = '';
            let currentAnswer = '';
            let gameActive = false;
            let instructionTimeout;
            const maxQuestionsPerRound = 8; // Number of questions per round
            let questionsAnsweredThisRound = 0; // Counter for questions in current round

            // DOM Elements (will be set dynamically inside init)
            let containerElement; // The main container passed from script.js
            let startScreenLevel1; // Renamed
            let gameScreenLevel1; // Renamed
            let gameOverScreenLevel1; // Renamed
            let round2IntroScreenLevel1; // Renamed
            let scoreDisplay;
            let instructionArea;
            let characterContainer;
            let stickMan;
            let actionButtons;

            let onLevelCompleteCallback = null; // Callback to notify main script

            // Audio Elements for SFX (Sound Effects) - UPDATED: Use your hosted audio URLs here
            // IMPORTANT: Replace 'https://your-domain.com/audio/' with the actual base URL where your audio files are hosted.
            const audioJumpSFX = new Audio('jump.mp3'); // REPLACE WITH YOUR JUMP AUDIO URL
            const audioDanceSFX = new Audio('dance.mp3'); // REPLACE WITH YOUR DANCE AUDIO URL
            const audioShoutSFX = new Audio('shout.mp3'); // REPLACE WITH YOUR SHOUT AUDIO URL
            const audioWrongSFX = new Audio('https://placehold.co/1x1?text=WrongAudio'); // REPLACE WITH YOUR WRONG AUDIO URL

            // Function to play sound effects
            function playSoundFile(audioElement, volume = 1.0) {
                if (audioElement) {
                    audioElement.pause(); // Stop if already playing
                    audioElement.currentTime = 0; // Rewind to the start
                    audioElement.volume = volume;
                    audioElement.play().catch(e => console.warn("Audio playback failed:", e));
                } else {
                    console.warn("Audio element is null or undefined.");
                }
            }

            // Available Actions and Phrases
            const actions = {
                round1: ['jump', 'dance', 'shout'],
                round2: ['jump', 'dance', 'shout'] // Instructions remain the same, but answers are mapped
            };

            // Round 2 Mapping Logic (Updated for 'dance')
            const round2Mapping = {
                'jump': 'shout', // Jump instruction now expects Shout action
                'dance': 'jump', // Dance instruction now expects Jump action
                'shout': 'dance' // Shout instruction now expects Dance action
            };

            // Web Speech API
            const synth = window.speechSynthesis;
            let currentUtterance = null;
            let selectedVoice = null; // Variable to store the selected female voice

            // --- Voice Loading and Selection ---
            function loadVoices() {
                const voices = synth.getVoices();
                // Try to find a common female English voice
                selectedVoice = voices.find(voice =>
                    voice.lang.startsWith('en-') &&
                    (voice.name.includes('Female') || voice.name.includes('Zira') || voice.name.includes('Karen') || voice.name.includes('Google US English'))
                );

                // Fallback if specific female voice not found (e.g., pick first English voice)
                if (!selectedVoice) {
                    selectedVoice = voices.find(voice => voice.lang.startsWith('en-'));
                }
                // If still no English voice, it will just use default, which is fine, but log it.
                if (!selectedVoice) {
                    console.warn("No suitable English voice found. Using default browser voice.");
                }
            }

            // Load voices when they are ready (important for cross-browser compatibility)
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = loadVoices;
            }
            loadVoices(); // Call once initially in case voices are already loaded

            // --- Helper Functions ---

            function speakPhrase(phrase, volume = 1.0, pitch = 1.0, rate = 1.0) {
                if (!synth) {
                    console.warn("Speech synthesis not supported in this browser.");
                    return;
                }
                if (currentUtterance && synth.speaking) {
                    synth.cancel(); // Cancel previous speech for a smoother transition
                }
                const utterance = new SpeechSynthesisUtterance(phrase);
                if (selectedVoice) { // Assign the selected voice if one was found
                    utterance.voice = selectedVoice;
                }
                utterance.volume = volume;
                utterance.pitch = pitch;
                utterance.rate = rate;
                currentUtterance = utterance;
                synth.speak(utterance);
                utterance.onend = () => {
                    if (currentUtterance === utterance) {
                        currentUtterance = null;
                    }
                };
            }

            // This function is now internal to level1Game and uses showInternalScreen from global scope
            function showScreenInternal(screenToShow) {
                // Hide all screens within the game's container first
                startScreenLevel1.classList.add('hidden');
                gameScreenLevel1.classList.add('hidden');
                gameOverScreenLevel1.classList.add('hidden');
                round2IntroScreenLevel1.classList.add('hidden');

                // Show the requested screen
                screenToShow.classList.remove('hidden');

                // Removed body.classList modifications to avoid conflicts with main game
            }

            function updateScoreDisplay() {
                scoreDisplay.textContent = `Score: ${score}`;
            }

            function getRandomElement(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            }

            function generateInstruction() {
                // Instructions always come from the base actions (jump, dance, shout)
                const availableInstructions = actions.round1; // No new instructions, just mapped answers in Round 2
                currentInstruction = getRandomElement(availableInstructions);

                // Determine the correct answer based on the current round
                if (currentRound === 2) {
                    currentAnswer = round2Mapping[currentInstruction]; // Mapped action is the correct answer
                } else {
                    currentAnswer = currentInstruction; // Follow instruction directly in Round 1
                }

                speakPhrase(currentInstruction, 1.0, 1.0, 1.0); // Speak the instruction
                resetInstructionTimeout();
            }

            function resetInstructionTimeout() {
                clearTimeout(instructionTimeout);
                instructionTimeout = setTimeout(() => {
                    if (gameActive) {
                        animateCharacter('none', false); // Trigger 'wrong' animation for timeout
                        speakPhrase("Too slow!", 1.0, 1.0, 1.0); // Voice for timeout
                        playSoundFile(audioWrongSFX); // Play specific SFX for timeout
                        handleIncorrectAnswer(true); // Pass true to indicate timeout, avoids double speech
                    }
                }, 4000); // 4 seconds to respond
            }

            function handleCorrectAnswer() {
                score++;
                questionsAnsweredThisRound++; // Increment question counter
                updateScoreDisplay();

                if (currentRound === 1 && questionsAnsweredThisRound >= maxQuestionsPerRound) { // Check questions for round progression
                    gameActive = false;
                    clearTimeout(instructionTimeout);
                    showScreenInternal(round2IntroScreenLevel1); // Show internal Round 2 intro
                    speakPhrase("Excellent! You've completed Round 1! Prepare for Round 2! The rules are changing!", 1.0, 1.0, 1.0);
                } else if (currentRound === 2 && questionsAnsweredThisRound >= maxQuestionsPerRound) { // Check questions for game completion
                    gameActive = false;
                    clearTimeout(instructionTimeout);
                    showScreenInternal(gameOverScreenLevel1); // Show internal Game Over screen
                    document.getElementById('final-score').textContent = score;
                    // Voice over for end of the game
                    speakPhrase(`Congratulations! You completed the game with a final score of ${score}!`, 1.0, 1.0, 1.0);
                    // This is where Level 1 completion is signaled to the main script
                    if (onLevelCompleteCallback) {
                        onLevelCompleteCallback(score); // Pass the score to the callback
                    }
                } else {
                    // Delay next instruction to allow feedback voice/SFX to complete
                    setTimeout(() => {
                        generateInstruction();
                    }, 1500); // Increased delay to 1.5 seconds for better audio separation
                }
            }

            function handleIncorrectAnswer(isTimeout = false) { // Added isTimeout parameter
                // score = Math.max(0, score - 1); // This line is commented out to remove negative marking
                questionsAnsweredThisRound++; // Increment question counter even for incorrect answers
                updateScoreDisplay();

                if (!isTimeout) { // Only speak "Wrong!" if it's not already spoken by timeout
                    speakPhrase("Wrong!", 1.0, 0.8, 1.0); // Voice for wrong action
                    playSoundFile(audioWrongSFX); // Play specific SFX for wrong answer
                    // Delay next instruction to allow feedback voice/SFX to complete
                    setTimeout(() => {
                        generateInstruction();
                    }, 1500); // Increased delay to 1.5 seconds for better audio separation
                } else {
                    // If it was a timeout, "Too slow!" and wrong SFX have already been spoken in resetInstructionTimeout
                    // Still delay to ensure the "Too slow!" voice finishes before the next instruction starts
                    setTimeout(() => {
                        generateInstruction();
                    }, 1500); // Increased delay to 1.5 seconds for consistency with incorrect answer
                }
            }

            /**
             * Resets the stick man to its default idle pose.
             * This is called when the game starts or a new round begins, or before a new animation.
             */
            function resetStickManPose() {
                gsap.killTweensOf("#stick-man, #stick-man > div"); // Stop any current animations

                // Reset all parts to their default CSS defined positions and rotations
                // Use clearProps: "all" to remove any inline styles GSAP might have set,
                // then re-apply essential base styles
                gsap.set(stickMan, {clearProps: "all"});
                gsap.set(stickMan.querySelector('.head'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.body'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.left-arm'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.right-arm'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.left-leg'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.right-leg'), {clearProps: "all"});
                gsap.set(stickMan.querySelector('.mouth'), {clearProps: "all"}); // Ensure mouth properties are cleared


                // Re-apply base styles that are crucial for appearance and initial transforms
                // These match the base styles in style.css
                gsap.set(stickMan.querySelector('.head'), { top: 0, left: 10, borderRadius: "50%", border: "3px solid black", backgroundColor: "white", transformOrigin: "bottom center" });
                gsap.set(stickMan.querySelector('.body'), { top: 55, left: 20, borderRadius: "5px 5px 20px 20px", backgroundColor: "black", transformOrigin: "top center" });
                gsap.set(stickMan.querySelector('.left-arm'), { top: 60, left: 15, rotation: 15, transformOrigin: "top center", backgroundColor: "black", borderRadius: 5 });
                gsap.set(stickMan.querySelector('.right-arm'), { top: 60, right: 15, rotation: -15, transformOrigin: "top center", backgroundColor: "black", borderRadius: 5 });
                gsap.set(stickMan.querySelector('.left-leg'), { top: 120, left: 25, rotation: 5, transformOrigin: "top center", backgroundColor: "black", borderRadius: 5 });
                gsap.set(stickMan.querySelector('.right-leg'), { top: 120, right: 25, rotation: -5, transformOrigin: "top center", backgroundColor: "black", borderRadius: 5 });

                // Explicitly reset mouth properties, including xPercent for perfect centering
                gsap.set(stickMan.querySelector('.mouth'), {
                    width: 25,
                    height: 5,
                    borderRadius: "50%",
                    border: "2px solid black",
                    backgroundColor: "transparent",
                    top: 38,
                    left: "50%",
                    xPercent: -50 // Crucial for centering after clearing all transforms
                });
            }


            /**
             * Triggers character animation using GSAP.
             * @param {string} actionType The type of action ('jump', 'dance', 'shout', 'none' for wrong).
             * @param {boolean} isCorrect True if the player's action was correct, false otherwise.
             */
            function animateCharacter(actionType, isCorrect) {
                // Always reset the pose before starting a new animation
                resetStickManPose();

                if (isCorrect) {
                    if (actionType === 'jump') {
                        playSoundFile(audioJumpSFX); // Play jump SFX
                        const jumpTl = gsap.timeline({defaults: {ease: "power1.out", duration: 0.15}}); // Shorter defaults for quick movements

                        // Crouch (Prep for jump)
                        jumpTl.to(stickMan.querySelector('.head'), {y: 5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.body'), {y: 5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.left-leg'), {rotation: 40, y: 5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.right-leg'), {rotation: -40, y: 5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.left-arm'), {rotation: 60, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.right-arm'), {rotation: -60, duration: 0.1}, 0)
                                .to(stickMan, {y: 10, duration: 0.1}, 0); // Whole stickman dips

                        // Jump Up
                        jumpTl.to(stickMan, {y: -100, duration: 0.3, ease: "power2.out"}, 0.1) // Main jump up
                                .to(stickMan.querySelector('.head'), {y: -15, duration: 0.3}, 0.1) // Head higher
                                .to(stickMan.querySelector('.body'), {y: -15, duration: 0.3}, 0.1) // Body higher
                                .to(stickMan.querySelector('.left-leg'), {rotation: -10, y: -20, duration: 0.3}, 0.1) // Legs extend
                                .to(stickMan.querySelector('.right-leg'), {rotation: 10, y: -20, duration: 0.3}, 0.1)
                                .to(stickMan.querySelector('.left-arm'), {rotation: -90, duration: 0.3}, 0.1) // Arms shoot up
                                .to(stickMan.querySelector('.right-arm'), {rotation: 90, duration: 0.3}, 0.1);

                        // Land
                        jumpTl.to(stickMan, {y: 0, duration: 0.2, ease: "power2.in"}, 0.4) // Land
                                .to(stickMan.querySelector('.head'), {y: 0, duration: 0.2}, 0.4)
                                .to(stickMan.querySelector('.body'), {y: 0, duration: 0.2}, 0.4)
                                .to(stickMan.querySelector('.left-leg'), {rotation: 5, y: 0, duration: 0.2}, 0.4) // Legs return to standing
                                .to(stickMan.querySelector('.right-leg'), {rotation: -5, y: 0, duration: 0.2}, 0.4)
                                .to(stickMan.querySelector('.left-arm'), {rotation: 15, duration: 0.2}, 0.4) // Arms return
                                .to(stickMan.querySelector('.right-arm'), {rotation: -15, duration: 0.2}, 0.4);


                    } else if (actionType === 'dance') {
                        playSoundFile(audioDanceSFX); // Play dance SFX
                        const danceTl = gsap.timeline({ repeat: 1, yoyo: true, defaults: { ease: "sine.inOut", duration: 0.2 }}); // Dance a little, then return

                        // Simple dance: Sway body, move arms and legs playfully
                        danceTl.to(stickMan, { y: -5, rotation: 3, duration: 0.15 }, 0) // Slight lift and tilt
                                .to(stickMan.querySelector('.left-arm'), { rotation: -70, duration: 0.15 }, 0)
                                .to(stickMan.querySelector('.right-arm'), { rotation: 70, duration: 0.15 }, 0)
                                .to(stickMan.querySelector('.left-leg'), { rotation: 20, duration: 0.15 }, 0)
                                .to(stickMan.querySelector('.right-leg'), { rotation: -20, duration: 0.15 }, 0)
                                .to(stickMan.querySelector('.head'), { rotation: 5, duration: 0.15 }, 0)

                                .to(stickMan, { y: 0, rotation: -3, duration: 0.15 }, 0.15) // Sway to other side
                                .to(stickMan.querySelector('.left-arm'), { rotation: 70, duration: 0.15 }, 0.15)
                                .to(stickMan.querySelector('.right-arm'), { rotation: -70, duration: 0.15 }, 0.15)
                                .to(stickMan.querySelector('.left-leg'), { rotation: -20, duration: 0.15 }, 0.15)
                                .to(stickMan.querySelector('.right-leg'), { rotation: 20, duration: 0.15 }, 0.15)
                                .to(stickMan.querySelector('.head'), { rotation: -5, duration: 0.15 }, 0.15);

                        // Return to idle pose (handled by `resetStickManPose` which is called before next instruction)
                    } else if (actionType === 'shout') {
                        playSoundFile(audioShoutSFX); // Play shout SFX
                        const shoutTl = gsap.timeline({defaults: {ease: "power1.out"}});

                        // Open mouth, tilt head, lean body, raise arms
                        shoutTl.to(stickMan.querySelector('.mouth'), {
                            width: 45,
                            height: 35,
                            borderRadius: "50%",
                            y: -8, // Move slightly up when opening
                            duration: 0.15,
                            ease: "power2.out"
                        }, 0)
                        .to(stickMan.querySelector('.head'), {rotation: 5, x: -5, duration: 0.15}, 0) // Head tilts back and shakes
                        .to(stickMan.querySelector('.body'), {rotation: 5, duration: 0.15}, 0) // Body leans forward
                        .to(stickMan.querySelector('.left-arm'), {rotation: -70, x: -5, duration: 0.15}, 0) // Arms raise out
                        .to(stickMan.querySelector('.right-arm'), {rotation: 70, x: 5, duration: 0.15}, 0)

                        // Sustain and more shake/movement
                        .to(stickMan.querySelector('.head'), {rotation: -5, x: 5, duration: 0.15}, 0.15)
                        .to(stickMan.querySelector('.body'), {rotation: -5, duration: 0.15}, 0.15)
                        .to(stickMan.querySelector('.left-arm'), {rotation: -80, x: -10, duration: 0.15}, 0.15)
                        .to(stickMan.querySelector('.right-arm'), {rotation: 80, x: 10, duration: 0.15}, 0.15)

                        // Return to idle
                        .to(stickMan.querySelector('.mouth'), {
                            width: 25,
                            height: 5,
                            borderRadius: "50%",
                            y: 0,
                            duration: 0.15,
                            ease: "power2.in"
                        }, 0.3)
                        .to(stickMan.querySelector('.head'), {rotation: 0, x: 0, duration: 0.15}, 0.3)
                        .to(stickMan.querySelector('.body'), {rotation: 0, duration: 0.15}, 0.3)
                        .to(stickMan.querySelector('.left-arm'), {rotation: 15, x: 0, duration: 0.15}, 0.3)
                        .to(stickMan.querySelector('.right-arm'), {rotation: -15, x: 0, duration: 0.15}, 0.3);

                    }

                } else {
                    // Wrong Action Animation
                    // The "Wrong!" voice or "Too slow!" voice is handled in handleIncorrectAnswer.
                    // SFX for wrong answer is also handled there.
                    const wrongTl = gsap.timeline({defaults: {ease: "power1.out"}});

                    wrongTl.to(stickMan.querySelector('.head'), {x: -10, rotation: -5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.head'), {x: 10, rotation: 5, duration: 0.1}, 0.1)
                                .to(stickMan.querySelector('.head'), {x: -5, rotation: -2, duration: 0.1}, 0.2)
                                .to(stickMan.querySelector('.head'), {x: 5, rotation: 2, duration: 0.1}, 0.3)
                                .to(stickMan.querySelector('.head'), {x: 0, rotation: 0, duration: 0.1}, 0.4);

                    wrongTl.to(stickMan.querySelector('.body'), {x: -5, duration: 0.1}, 0)
                                .to(stickMan.querySelector('.body'), {x: 5, duration: 0.1}, 0.1)
                                .to(stickMan.querySelector('.body'), {x: -2, duration: 0.1}, 0.2)
                                .to(stickMan.querySelector('.body'), {x: 2, duration: 0.1}, 0.3)
                                .to(stickMan.querySelector('.body'), {x: 0, duration: 0.1}, 0.4);
                }
            }

            // --- Game Flow Functions ---

            function startGame() {
                score = 0;
                currentRound = 1;
                questionsAnsweredThisRound = 0; // Reset question counter for new game
                gameActive = true;
                updateScoreDisplay();
                showScreenInternal(gameScreenLevel1); // Use internal showScreen
                console.log("Level 1 Game: Starting game (internal).");
                resetStickManPose(); // Ensure stick man is in neutral pose at game start
                // Voice over for entering the game
                speakPhrase("Welcome to Respond or React! Let's begin Round 1!", 1.0, 1.0, 1.0);
                generateInstruction();
            }

            function startRound2() {
                currentRound = 2;
                questionsAnsweredThisRound = 0; // Reset question counter for Round 2
                gameActive = true;
                showScreenInternal(gameScreenLevel1); // Use internal showScreen
                console.log("Level 1 Game: Starting Round 2.");
                resetStickManPose(); // Ensure stick man is in neutral pose at round 2 start
                // Voice over for entering Round 2 (already existed, keeping for clarity)
                speakPhrase("Welcome to Round 2! The rules are changing!", 1.0, 1.0, 1.0);
                generateInstruction();
            }

            function restartGame() {
                console.log("Level 1 Game: Restarting game.");
                startGame();
            }

            function goHome() {
                gameActive = false;
                clearTimeout(instructionTimeout);
                if (currentUtterance) {
                    synth.cancel(); // Stop any ongoing speech
                }
                showScreenInternal(startScreenLevel1); // Use internal showScreen
                console.log("Level 1 Game: Going to internal home screen.");
                resetStickManPose();
            }

            // --- Public API for level1Game ---
            function initLevel(mainContainer, onComplete) {
                containerElement = mainContainer;
                onLevelCompleteCallback = onComplete;
                console.log("Level 1 Game: Initializing...");

                // Assign DOM elements once HTML is loaded - now query within containerElement
                startScreenLevel1 = containerElement.querySelector('#start-screen-level1');
                gameScreenLevel1 = containerElement.querySelector('#game-screen-level1');
                gameOverScreenLevel1 = containerElement.querySelector('#game-over-screen-level1');
                round2IntroScreenLevel1 = containerElement.querySelector('#round-2-intro-level1');
                scoreDisplay = containerElement.querySelector('#score-display');
                instructionArea = containerElement.querySelector('#instruction-area'); // Still reference, but will be hidden
                characterContainer = containerElement.querySelector('#character-container');
                stickMan = containerElement.querySelector('#stick-man');
                actionButtons = containerElement.querySelector('#action-buttons');

                // Add event listeners specific to Level 1
                // Ensure event listeners are attached to elements within the specific level's container
                startScreenLevel1.querySelector('#start-button-level1').addEventListener('click', startGame);
                gameOverScreenLevel1.querySelector('#play-again-button-level1').addEventListener('click', restartGame);
                round2IntroScreenLevel1.querySelector('#proceed-to-round2-button-level1').addEventListener('click', startRound2);
                gameOverScreenLevel1.querySelector('#back-to-home-button-level1').addEventListener('click', goHome);

                // Use a named function for event listener to allow proper removal
                const handleActionButtonClick = (event) => {
                    if (!gameActive) return;

                    const clickedButton = event.target.closest('button');
                    if (!clickedButton) return;
                     if (synth && synth.speaking) {
        synth.cancel();
    }

                    const action = clickedButton.dataset.action; // Get the action from data-action attribute

                    clearTimeout(instructionTimeout); // Clear timeout on player action

                    if (action === currentAnswer) {
                        animateCharacter(action, true);
                        handleCorrectAnswer(); // handleCorrectAnswer will now proceed without speaking "Correct!"
                    } else {
                        animateCharacter('none', false); // Pass 'none' for general incorrect animation
                        handleIncorrectAnswer(); // handleIncorrectAnswer will speak "Wrong!" and play SFX
                    }
                };
                actionButtons.addEventListener('click', handleActionButtonClick);
                // Store the reference to remove it later
                actionButtons._level1Handler = handleActionButtonClick;


                // Initial screen setup for Level 1 when it's loaded
                showScreenInternal(startScreenLevel1);
                console.log("Level 1 Game: Showing internal start screen.");
                resetStickManPose();
            }

            function stopLevel() {
                gameActive = false;
                clearTimeout(instructionTimeout);
                if (currentUtterance) {
                    synth.cancel(); // Stop any ongoing speech
                }
                console.log("Level 1 Game: Stopping and cleaning up.");
                // Remove event listeners to prevent memory leaks and conflicts
                if (startScreenLevel1 && startScreenLevel1.querySelector('#start-button-level1')) {
                    startScreenLevel1.querySelector('#start-button-level1').removeEventListener('click', startGame);
                }
                if (gameOverScreenLevel1 && gameOverScreenLevel1.querySelector('#play-again-button-level1')) {
                    gameOverScreenLevel1.querySelector('#play-again-button-level1').removeEventListener('click', restartGame);
                }
                if (round2IntroScreenLevel1 && round2IntroScreenLevel1.querySelector('#proceed-to-round2-button-level1')) {
                    round2IntroScreenLevel1.querySelector('#proceed-to-round2-button-level1').removeEventListener('click', startRound2);
                }
                if (gameOverScreenLevel1 && gameOverScreenLevel1.querySelector('#back-to-home-button-level1')) {
                    gameOverScreenLevel1.querySelector('#back-to-home-button-level1').removeEventListener('click', goHome);
                }
                if (actionButtons && actionButtons._level1Handler) {
                    actionButtons.removeEventListener('click', actionButtons._level1Handler);
                    actionButtons._level1Handler = null; // Clear reference
                }


                containerElement = null; // Clear reference
                onLevelCompleteCallback = null; // Clear reference
            }

            return {
                init: initLevel,
                stop: stopLevel
            };
        })();
        document.getElementById("start-game-button-level2").addEventListener("click", () => {
    // Remove white background from outer container
    document.getElementById("gameContainer").classList.add("no-background");

    // Hide Level 2 start screen, show main game
    document.getElementById("start-screen-level2").classList.remove("active");
});
document.getElementById("back-to-home-button-level1")?.addEventListener("click", () => {
    document.getElementById("gameContainer").classList.remove("no-background");
});
document.getElementById("gameContainer").classList.add("no-background");




        function initializeLevel1Game() {
            console.log("Initializing Level 1 game...");
            // Pass the specific container for Level 1 game content
            const level1GameContentDiv = document.getElementById('level1GameContent');
            level1Game.init(level1GameContentDiv, completeLevel1);
        }

        /**
         * Initializes Level 2 game.
         * Copy your Level 2 game's JavaScript code into this function.
         * Similar to Level 1, manage global variables carefully.
         */
        const level2Game = (function() {
            // MODIFIED: Restricting available colors to the specified list
            const COLORS = {
                'red': '#e74c3c',
                'green': '#2ecc71',
                'blue': '#3498db',
                'purple': '#9b59b6',
                'white': '#ecf0f1',
                'black': '#2c3e50'
            };
            const COLOR_NAMES = Object.keys(COLORS); // This will now only contain the allowed colors

            const MAX_ROUNDS = 15;
            const ROUND_DURATION_MS = 3000;
            const NEXT_ROUND_DELAY_MS = 3000;

            let currentRound = 0;
            let score = 0;
            let correctColor = ''; // Stores the name of the correct color (e.g., 'red')
            let roundTimeout = null;
            let processingAnswer = false;

            // DOM elements (will be assigned in init)
            let containerElement;
            let wordDisplay;
            let colorButtons = []; // Array to hold button references
            let colorButtonTexts = []; // Array to hold span references for button text
            let scoreDisplay;
            let roundDisplay;
            let timerBar;
            let startScreen;
            let endScreen;
            let startGameButton;
            let restartGameButton;

            let onLevelCompleteCallback = null;

            const speak = (text) => {
                console.log(`TTS: "${text}"`);
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'en-US';
                    utterance.pitch = 1;
                    utterance.rate = 1.1;
                    utterance.volume = 1;
                    speechSynthesis.speak(utterance);
                } else {
                    console.warn("Speech Synthesis API not supported in this browser.");
                }
            };

            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            };

            const startRound = () => {
                currentRound++;
                console.log(`--- STARTING ROUND ${currentRound} ---`);

                if (currentRound > MAX_ROUNDS) {
                    endGame();
                    return;
                }

                processingAnswer = false;
                console.log(`Round ${currentRound}: 'processingAnswer' set to ${processingAnswer}`);

                resetTimerBar();
                startRoundTimer();

                roundDisplay.textContent = currentRound;

                // The colors for wordToDisplay and textColorName will now be chosen only from the restricted COLOR_NAMES
                let wordToDisplay = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
                let textColorName = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];

                while (wordToDisplay === textColorName) {
                    textColorName = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
                }

                wordDisplay.textContent = wordToDisplay.toUpperCase();
                wordDisplay.style.color = COLORS[textColorName];
                correctColor = textColorName;
                console.log(`Displaying "${wordToDisplay.toUpperCase()}" in ${textColorName} color. Correct answer: "${correctColor}"`);

                let choices = new Set();
                choices.add(correctColor);

                // The choices for buttons will also be chosen only from the restricted COLOR_NAMES
                while (choices.size < 4) {
                    const randomColorName = COLOR_NAMES[Math.floor(Math.random() * COLOR_NAMES.length)];
                    choices.add(randomColorName);
                }
                const shuffledChoices = shuffleArray(Array.from(choices));

                colorButtons.forEach((button, index) => {
                    const optionColorName = shuffledChoices[index];
                    const buttonTextSpan = colorButtonTexts[index];

                    button.dataset.color = optionColorName;
                    button.disabled = false;

                    buttonTextSpan.textContent = optionColorName.toUpperCase();

                    console.log(`Button ${index + 1} displays "${optionColorName.toUpperCase()}". Data Color: "${optionColorName}", Disabled: ${button.disabled}`);
                });

                roundTimeout = setTimeout(() => {
                    console.log("TIMEOUT FIRED!");
                    handleAnswer(null);
                }, ROUND_DURATION_MS);
            };

            const handleAnswer = (selectedColorName) => {
                console.log(`handleAnswer called. Selected: "${selectedColorName}". 'processingAnswer': ${processingAnswer}`);

                if (processingAnswer) {
                    console.log("Answer already being processed for this round. Ignoring this call.");
                    return;
                }
                processingAnswer = true;
                console.log(`'processingAnswer' set to ${processingAnswer}`);

                clearTimeout(roundTimeout);

                colorButtons.forEach(button => {
                    button.disabled = true;
                    console.log(`Button ${button.id} disabled.`);
                });

                if (selectedColorName === correctColor) {
                    score++;
                    speak(`You chose ${selectedColorName}. Correct!`);
                    console.log(`Answer: CORRECT! Score: ${score}`);
                } else {
                    if (selectedColorName) {
                        speak(`You chose ${selectedColorName}. Wrong! That was ${correctColor}.`);
                        console.log(`Answer: INCORRECT! Chose: "${selectedColorName}". Correct was: "${correctColor}". Score: ${score}`);
                    } else {
                        speak(`Time's up! That was ${correctColor}.`);
                        console.log(`Answer: TIMEOUT! Correct was: "${correctColor}". Score: ${score}`);
                    }
                }
                scoreDisplay.textContent = score;

                console.log(`Waiting ${NEXT_ROUND_DELAY_MS / 1000} seconds before next round.`);
                setTimeout(startRound, NEXT_ROUND_DELAY_MS);
            };

            const startRoundTimer = () => {
                timerBar.style.width = '100%';
                timerBar.style.transition = `width ${ROUND_DURATION_MS / 1000}s linear`;
                timerBar.style.width = '0%';
            };

            const resetTimerBar = () => {
                timerBar.style.transition = 'none';
                timerBar.style.width = '100%';
                setTimeout(() => {
                    timerBar.style.transition = `width ${ROUND_DURATION_MS / 1000}s linear`;
                }, 50);
            };

            const startGame = () => {
                console.log("Level 2 Game: Started.");
                currentRound = 0;
                score = 0;
                scoreDisplay.textContent = score;
                startScreen.classList.remove('active');
                endScreen.classList.remove('active');
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                }
                startRound();
            };

            const endGame = () => {
                console.log("Level 2 Game: Ended.");
                finalScoreDisplay.textContent = score;
                endScreen.classList.add('active');
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                }
                // Signal completion to the main script if all rounds are done
                if (currentRound >= MAX_ROUNDS && onLevelCompleteCallback) {
                    onLevelCompleteCallback(score); // Pass the score to the callback
                }
            };

            // --- Public API for level2Game ---
            function initLevel(mainContainer, onComplete) {
                containerElement = mainContainer;
                onLevelCompleteCallback = onComplete;
                console.log("Level 2 Game: Initializing...");

                // Assign DOM elements by querying within the specific containerElement
                wordDisplay = containerElement.querySelector('#word-display-level2');
                colorButtons = [
                    containerElement.querySelector('#choice-1-level2'),
                    containerElement.querySelector('#choice-2-level2'),
                    containerElement.querySelector('#choice-3-level2'),
                    containerElement.querySelector('#choice-4-level2')
                ];
                // Map the text spans within the buttons
                colorButtonTexts = colorButtons.map(button => button.querySelector('.color-button-text'));

                scoreDisplay = containerElement.querySelector('#score-level2');
                roundDisplay = containerElement.querySelector('#round-level2');
                timerBar = containerElement.querySelector('#timer-bar-level2');
                startScreen = containerElement.querySelector('#start-screen-level2');
                startGameButton = containerElement.querySelector('#start-game-button-level2');
                endScreen = containerElement.querySelector('#end-screen-level2');
                finalScoreDisplay = containerElement.querySelector('#final-score-level2');
                restartGameButton = containerElement.querySelector('#restart-game-button-level2');


                // Add event listeners
                startGameButton.addEventListener('click', startGame);
                restartGameButton.addEventListener('click', startGame);

                // Use a named function for event listener to allow proper removal
                const handleColorButtonClick = (event) => {
                    const selectedColor = event.currentTarget.dataset.color;
                    console.log(`BUTTON CLICKED! ID: ${event.currentTarget.id}, Data Color: "${selectedColor}", Disabled: ${event.currentTarget.disabled}, 'processingAnswer': ${processingAnswer}`);

                    if (!processingAnswer && selectedColor && !event.currentTarget.disabled) {
                        console.log(`Processing click for "${selectedColor}"`);
                        handleAnswer(selectedColor);
                    } else {
                        console.log("Click ignored: Reason - either answer already processing, no color data, or button disabled.");
                    }
                };
                colorButtons.forEach(button => {
                    button.addEventListener('click', handleColorButtonClick);
                    button._level2Handler = handleColorButtonClick; // Store reference for removal
                });

                // Initial setup for Level 2 when it's loaded by the main script
                showInternalScreen(containerElement, startScreen);
                console.log("Level 2 Game: Showing internal start screen.");
            }

            function stopLevel() {
                console.log("Level 2 Game: Stopping and cleaning up.");
                clearInterval(roundTimeout); // Clear any pending round timeouts
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel(); // Stop any ongoing speech
                }

                // Remove event listeners to prevent memory leaks
                if (startGameButton) {
                    startGameButton.removeEventListener('click', startGame);
                }
                if (restartGameButton) {
                    restartGameButton.removeEventListener('click', startGame);
                }
                colorButtons.forEach(button => {
                    if (button._level2Handler) {
                        button.removeEventListener('click', button._level2Handler);
                        button._level2Handler = null;
                    }
                });

                // Reset internal game state
                score = 0;
                currentRound = 0;
                processingAnswer = false;
                wordDisplay.textContent = '';
                wordDisplay.style.color = '';
                colorButtons.forEach(button => {
                    button.style.backgroundColor = '';
                    button.querySelector('.color-button-text').textContent = '';
                    button.dataset.color = '';
                    button.disabled = false;
                });
                showInternalScreen(containerElement, null); // Hide all internal screens

                // Clear references
                containerElement = null;
                onLevelCompleteCallback = null;
                wordDisplay = null;
                colorButtons = [];
                colorButtonTexts = [];
                scoreDisplay = null;
                roundDisplay = null;
                timerBar = null;
                startScreen = null;
                endScreen = null;
                startGameButton = null;
                restartGameButton = null;
            }

            return {
                init: initLevel,
                stop: stopLevel
            };
        })();


        function initializeLevel2Game() {
            console.log("Initializing Level 2 game...");
            const level2GameContentDiv = document.getElementById('level2GameContent');
            level2Game.init(level2GameContentDiv, completeLevel2);
        }

        /**
         * Function to be called by your Level 1 game when it's completed.
         * This handles the transition to the Level 1 completion screen.
         * @param {number} finalScore The score from Level 1.
         */
        function completeLevel1(finalScore) {
            level1Completed = true;
            showScreen(level1CompleteScreen);
            level1FinalScoreDisplay.textContent = finalScore; // Display Level 1 score
            console.log("Level 1 completed! Score:", finalScore);
            // Enable the "Go to Level 2" button
            goToLevel2Button.classList.remove('disabled-button');
            goToLevel2Button.disabled = false;
            // Stop and clean up Level 1 game when it's done
            level1Game.stop();
        }

        /**
         * Function to be called by your Level 2 game when it's completed.
         * This handles the transition to the Game Over screen.
         * @param {number} finalScore The score from Level 2.
         */
        function completeLevel2(finalScore) {
            showScreen(gameOverScreen);
            gameTotalScoreDisplay.textContent = finalScore; // Display total game score (Level 2's score)
            console.log("Level 2 completed! Total Score:", finalScore);
            // Stop and clean up Level 2 game when it's done
            level2Game.stop();
        }

        /**
         * Resets Level 1 game state.
         * Implement any necessary cleanup or state resets for your Level 1 game here.
         */
        function resetLevel1Game() {
            console.log("Resetting Level 1 game...");
            // Call the stop function of the level1Game module
            level1Game.stop();
        }

        /**
         * Resets Level 2 game state.
         * Implement any necessary cleanup or state resets for your Level 2 game here.
         */
        function resetLevel2Game() {
            console.log("Resetting Level 2 game...");
            level2Game.stop();
        }

        // Initial setup: Ensure only the start screen is visible on load
        window.onload = () => {
            showScreen(startScreen);
            console.log("Window loaded. Showing Start Screen.");
            // Ensure "Go to Level 2" button is disabled on initial load
            goToLevel2Button.classList.add('disabled-button');
            goToLevel2Button.disabled = true;
        };

    </script>
</body>
</html>
